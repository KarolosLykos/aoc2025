// Code generated by aoc; DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	fmt.Println("Year: 2025| Day: 08")
	input, err := parseInput("input.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println("Part A: ", partA(input))
	fmt.Println("Part B: ", partB(input))
	fmt.Println("Finished: ", time.Since(start))
}

type box struct {
	x, y, z int
	circuit *circuit
}

type circuit struct {
	boxes []*box
}

func calcRoughDistance(b1, b2 *box) int {
	x := b1.x - b2.x
	y := b1.y - b2.y
	z := b1.z - b2.z
	return x*x + y*y + z*z
}

func partA(lines []string) any {
	boxes := make([]*box, 0)
	for _, line := range lines {
		parts := strings.Split(line, ",")
		x, _ := strconv.Atoi(parts[0])
		y, _ := strconv.Atoi(parts[1])
		z, _ := strconv.Atoi(parts[2])
		boxes = append(boxes, &box{
			x: x,
			y: y,
			z: z,
		})
	}

	iters := 10
	if len(boxes) > 20 {
		iters = 1000
	}

	distances := map[*box]map[*box]int{}

	type edge struct {
		b1, b2   *box
		distance int
	}

	allEdges := []edge{}
	for i, b1 := range boxes {
		distances[b1] = map[*box]int{}
		for _, b2 := range boxes[i+1:] {
			allEdges = append(allEdges, edge{
				b1:       b1,
				b2:       b2,
				distance: calcRoughDistance(b1, b2),
			})
		}
	}

	sort.Slice(allEdges, func(i int, j int) bool {
		return allEdges[i].distance < allEdges[j].distance
	})

	circuits := []*circuit{}

	for range iters {
		closestEdge := allEdges[0]
		allEdges = allEdges[1:]

		if closestEdge.b1.circuit == nil && closestEdge.b2.circuit == nil {
			circuits = append(circuits, &circuit{
				boxes: []*box{
					closestEdge.b1,
					closestEdge.b2,
				},
			})
			closestEdge.b1.circuit = circuits[len(circuits)-1]
			closestEdge.b2.circuit = circuits[len(circuits)-1]
		} else if closestEdge.b1.circuit == nil {
			closestEdge.b2.circuit.boxes = append(closestEdge.b2.circuit.boxes, closestEdge.b1)
			closestEdge.b1.circuit = closestEdge.b2.circuit
		} else if closestEdge.b2.circuit == nil {
			closestEdge.b1.circuit.boxes = append(closestEdge.b1.circuit.boxes, closestEdge.b2)
			closestEdge.b2.circuit = closestEdge.b1.circuit
		} else if closestEdge.b1.circuit != closestEdge.b2.circuit {
			// combine two circuits
			oldCircuit := closestEdge.b2.circuit
			for _, box := range closestEdge.b2.circuit.boxes {
				closestEdge.b1.circuit.boxes = append(closestEdge.b1.circuit.boxes, box)
				box.circuit = closestEdge.b1.circuit
			}

			// remove oldCircuit
			for i := range circuits {
				if circuits[i] == oldCircuit {
					circuits[len(circuits)-1], circuits[i] = circuits[i], circuits[len(circuits)-1]
					circuits = circuits[:len(circuits)-1]
					break
				}
			}
		}
	}

	circuitSizes := []int{}
	for _, c := range circuits {
		circuitSizes = append(circuitSizes, len(c.boxes))
	}

	sort.Ints(circuitSizes)

	ans := 1
	for i := range 3 {
		ans *= circuitSizes[len(circuitSizes)-1-i]
	}

	return ans
}

func partB(lines []string) any {

	boxes := make([]*box, 0)
	for _, line := range lines {
		parts := strings.Split(line, ",")
		x, _ := strconv.Atoi(parts[0])
		y, _ := strconv.Atoi(parts[1])
		z, _ := strconv.Atoi(parts[2])
		boxes = append(boxes, &box{
			x: x,
			y: y,
			z: z,
		})
	}

	distances := map[*box]map[*box]int{}

	type edge struct {
		b1, b2   *box
		distance int
	}

	allEdges := []edge{}
	for i, b1 := range boxes {
		distances[b1] = map[*box]int{}
		for _, b2 := range boxes[i+1:] {
			allEdges = append(allEdges, edge{
				b1:       b1,
				b2:       b2,
				distance: calcRoughDistance(b1, b2),
			})
		}
	}

	sort.Slice(allEdges, func(i int, j int) bool {
		return allEdges[i].distance < allEdges[j].distance
	})

	circuits := []*circuit{}

	for len(allEdges) > 0 {
		closestEdge := allEdges[0]
		allEdges = allEdges[1:]

		if closestEdge.b1.circuit == nil && closestEdge.b2.circuit == nil {
			circuits = append(circuits, &circuit{
				boxes: []*box{
					closestEdge.b1,
					closestEdge.b2,
				},
			})
			closestEdge.b1.circuit = circuits[len(circuits)-1]
			closestEdge.b2.circuit = circuits[len(circuits)-1]
		} else if closestEdge.b1.circuit == nil {
			closestEdge.b2.circuit.boxes = append(closestEdge.b2.circuit.boxes, closestEdge.b1)
			closestEdge.b1.circuit = closestEdge.b2.circuit
		} else if closestEdge.b2.circuit == nil {
			closestEdge.b1.circuit.boxes = append(closestEdge.b1.circuit.boxes, closestEdge.b2)
			closestEdge.b2.circuit = closestEdge.b1.circuit
		} else if closestEdge.b1.circuit != closestEdge.b2.circuit {
			// combine two circuits
			oldCircuit := closestEdge.b2.circuit
			for _, box := range closestEdge.b2.circuit.boxes {
				closestEdge.b1.circuit.boxes = append(closestEdge.b1.circuit.boxes, box)
				box.circuit = closestEdge.b1.circuit
			}

			// remove oldCircuit
			for i := range circuits {
				if circuits[i] == oldCircuit {
					circuits[len(circuits)-1], circuits[i] = circuits[i], circuits[len(circuits)-1]
					circuits = circuits[:len(circuits)-1]
					break
				}
			}
		}

		// if this is the join that makes the entire circuit the size of all boxes, then break out
		// and return final calc.
		// note that this works in the "no join added" as well because this returns true on the first
		// instance where circuit length is equal to length of all boxes
		if len(closestEdge.b1.circuit.boxes) == len(boxes) {
			return closestEdge.b1.x * closestEdge.b2.x
		}
	}

	return 0
}

func parseInput(filename string) ([]string, error) {
	_, thisFile, _, _ := runtime.Caller(0)
	dir := filepath.Dir(thisFile)
	filename = filepath.Join(dir, filename)

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	lines := make([]string, 0)

	s := bufio.NewScanner(f)
	for s.Scan() {
		lines = append(lines, s.Text())
	}

	return lines, nil
}
