// Code generated by aoc; DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	fmt.Println("Year: 2025| Day: 09")
	input, err := parseInput("input.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println("Part A: ", partA(input))
	fmt.Println("Part B: ", partB(input))
	fmt.Println("Finished: ", time.Since(start))
}

type Tile struct {
	X int
	Y int
}

func partA(lines []string) any {
	tiles := make([]Tile, 0)
	for _, l := range lines {
		loc := strings.Split(l, ",")
		x, _ := strconv.Atoi(loc[0])
		y, _ := strconv.Atoi(loc[1])

		tiles = append(tiles, Tile{X: x, Y: y})
	}

	sort.Slice(tiles, func(i, j int) bool {
		return tiles[i].Y < tiles[j].Y
	})

	rectMax := 0
	for _, t := range tiles {
		for _, t2 := range tiles {
			if t.Y < t2.Y {
				continue
			}

			if t.X == t2.X && t.Y == t2.Y {
				continue
			}

			minX, maxX, minY, maxY := min(t.X, t2.X), max(t.X, t2.X), min(t.Y, t2.Y), max(t.Y, t2.Y)
			area := (maxX - minX + 1) * (maxY - minY + 1)
			if rectMax < area {
				rectMax = area
			}
		}
	}

	return rectMax
}

func partB(lines []string) any {
	coords := make([][2]int, 0)
	for _, line := range lines {
		parts := strings.Split(line, ",")
		x, _ := strconv.Atoi(parts[0])
		y, _ := strconv.Atoi(parts[1])
		coords = append(coords, [2]int{x,y})
	}
	// store both coords that make up an edge
	horizontalEdges := [][][2]int{}
	verticalEdges := [][][2]int{}

	for i := range len(coords) {
		c1, c2 := coords[i], coords[(i+1)%len(coords)]
		if c1[0] == c2[0] {
			// cols are equal, have a vertical edge
			verticalEdges = append(verticalEdges, [][2]int{
				c1, c2,
			})
		} else {
			// horizontal edge
			horizontalEdges = append(horizontalEdges, [][2]int{
				c1, c2,
			})
		}
	}

	largest := 0
	for i, c1 := range coords {
		for _, c2 := range coords[i+1:] {

			// check every potential pair of coords

			leftCol := min(c1[0], c2[0])
			rightCol := max(c1[0], c2[0])
			topRow := min(c1[1], c2[1])
			bottomRow := max(c1[1], c2[1])
			size := (bottomRow - topRow + 1) * (rightCol - leftCol + 1)

			// optimization to skip pairs that are smaller than a previous result
			if size <= largest {
				continue
			}

			// check if any edges break into this rectangle, if so do not update largest
			isContinuous := true

			for _, edge := range horizontalEdges {
				row := edge[0][1]
				// check horizontal edge is within the rows of the current rectangle
				if row <= topRow || row >= bottomRow {
					continue
				}

				edgeLeft := min(edge[0][0], edge[1][0])
				edgeRight := max(edge[0][0], edge[1][0])

				// final bug fix was removing = from these conditionals
				// i'm not entirely sure why that works but something about the corners of two edges
				if edgeLeft <= leftCol && edgeRight > leftCol {
					isContinuous = false
					break
				} else if edgeLeft < rightCol && edgeRight >= rightCol {
					isContinuous = false
					break
				}
			}
			if !isContinuous {
				continue
			}

			// same thing for verticalEdges
			for _, edge := range verticalEdges {
				col := edge[0][0]
				// check horizontal edge is within the rows of the current rectangle
				if col <= leftCol || col >= rightCol {
					continue
				}

				edgeTop := min(edge[0][1], edge[1][1])
				edgeBottom := max(edge[0][1], edge[1][1])

				if edgeTop <= topRow && edgeBottom > topRow {
					isContinuous = false
					break
				} else if edgeTop < bottomRow && edgeBottom >= bottomRow {
					isContinuous = false
					break
				}
			}
			if !isContinuous {
				continue
			}

			largest = size
		}
	}

	return largest
}

func parseInput(filename string) ([]string, error) {
	_, thisFile, _, _ := runtime.Caller(0)
	dir := filepath.Dir(thisFile)
	filename = filepath.Join(dir, filename)

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	lines := make([]string, 0)

	s := bufio.NewScanner(f)
	for s.Scan() {
		lines = append(lines, s.Text())
	}

	return lines, nil
}
