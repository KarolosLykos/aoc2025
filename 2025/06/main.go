// Code generated by aoc; DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	fmt.Println("Year: 2025| Day: 06")
	input, err := parseInput("input.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println("Part A: ", partA(input))
	fmt.Println("Part B: ", partB(input))
	fmt.Println("Finished: ", time.Since(start))
}

type Column struct {
	Problems []string
	Op       string
}

func partA(lines []string) any {
	ops := strings.Fields(lines[len(lines)-1])
	problems := lines[:len(lines)-1]

	var rows [][]int
	for _, line := range problems {
		fields := strings.Fields(line)
		nums := make([]int, len(fields))
		for i, f := range fields {
			n, _ := strconv.Atoi(f)
			nums[i] = n
		}
		rows = append(rows, nums)
	}

	cols := len(rows[0])
	results := 0

	for c := 0; c < cols; c++ {
		result := rows[0][c]

		for r := 1; r < len(rows); r++ {
			switch ops[c] {
			case "*":
				result *= rows[r][c]
			case "+":
				result += rows[r][c]
			}
		}

		results += result
	}

	return results
}
type problem struct {
	op   string
	nums []int
}

func partB(lines []string) any {
	grid := [][]string{}
	for _, l := range lines {
		grid = append(grid, strings.Split(l, ""))
	}

	problems := []problem{}
	for col := len(grid[0]) - 1; col >= 0; col-- {
		if len(problems) == 0 {
			problems = append(problems, problem{})
		}
		chunk := ""
		for row := 0; row < len(grid); row++ {
			// end of row reached, handle the chunk and potentially an operation
			if row == len(grid)-1 {
				// handle chunked number
				chunk = strings.TrimSpace(chunk)

				// skip empty columns
				if chunk == "" {
					continue
				}

				ch, _ := strconv.Atoi(chunk)
				problems[len(problems)-1].nums = append(problems[len(problems)-1].nums, ch)

				// handle op
				if grid[row][col] != " " {
					op := grid[row][col]
					problems[len(problems)-1].op = op

					// add new problem to begin chunking
					if col != 0 {
						problems = append(problems, problem{})
					}
				}
			} else {
				chunk += grid[row][col]
			}
		}
	}

	return scoreProblems(problems)
}

func scoreProblems(problems []problem) int {
	ans := 0

	for _, p := range problems {
		if p.op == "*" {
			s := 1
			for _, n := range p.nums {
				s *= n
			}
			ans += s
		} else if p.op == "+" {
			s := 0
			for _, n := range p.nums {
				s += n
			}
			ans += s
		} else {
			panic("unexpected op: " + p.op)
		}
	}

	return ans
}

func parseInput(filename string) ([]string, error) {
	_, thisFile, _, _ := runtime.Caller(0)
	dir := filepath.Dir(thisFile)
	filename = filepath.Join(dir, filename)

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	lines := make([]string, 0)

	s := bufio.NewScanner(f)
	for s.Scan() {
		lines = append(lines, s.Text())
	}

	return lines, nil
}
