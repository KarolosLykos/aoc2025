// Code generated by aoc; DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	fmt.Println("Year: 2025| Day: 05")
	input, err := parseInput("input.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println("Part A: ", partA(input))
	fmt.Println("Part B: ", partB(input))
	fmt.Println("Finished: ", time.Since(start))
}

type Intervals struct {
	Start int
	End   int
}

func partA(lines []string) any {
	lineReached := false
	count := 0
	intervals := make([]Intervals, 0)

	for _, l := range lines {
		if l != "" {
			ranges := strings.Split(l, "-")
			start, err := strconv.Atoi(ranges[0])
			if err != nil {
				fmt.Println("could not part start range: ", err)
				continue
			}

			end, err := strconv.Atoi(ranges[1])
			if err != nil {
				fmt.Println("could not part end range: ", err)
				continue
			}

			intervals = append(intervals, Intervals{Start: start, End: end})
			continue
		}

		break
	}

	merged := mergeIntervals(intervals)

	for _, l := range lines {
		if l != "" && !lineReached {
			continue
		}
		if l == "" {
			lineReached = true
			continue
		}

		for _, m := range merged {
			ingr, err := strconv.Atoi(l)
			if err != nil {
				fmt.Println("could not part ingr range: ", err)
				continue
			}

			if ingr >= m.Start && ingr <= m.End {
				count++
			}
		}
	}

	return count
}

func partB(lines []string) any {
	count := 0
	intervals := make([]Intervals, 0)

	for _, l := range lines {
		if l != "" {
			ranges := strings.Split(l, "-")
			start, err := strconv.Atoi(ranges[0])
			if err != nil {
				fmt.Println("could not part start range: ", err)
				continue
			}

			end, err := strconv.Atoi(ranges[1])
			if err != nil {
				fmt.Println("could not part end range: ", err)
				continue
			}

			intervals = append(intervals, Intervals{Start: start, End: end})
			continue
		}

		break
	}

	merged := mergeIntervals(intervals)

	for _, m := range merged {
		count += m.End - m.Start + 1
	}

	return count
}

func parseInput(filename string) ([]string, error) {
	_, thisFile, _, _ := runtime.Caller(0)
	dir := filepath.Dir(thisFile)
	filename = filepath.Join(dir, filename)

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	lines := make([]string, 0)

	s := bufio.NewScanner(f)
	for s.Scan() {
		lines = append(lines, s.Text())
	}

	return lines, nil
}

func mergeIntervals(intervals []Intervals) []Intervals {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i].Start < intervals[j].Start
	})

	merged := make([]Intervals, 0)
	merged = append(merged, intervals[0])

	for _, curr := range intervals[1:] {
		last := &merged[len(merged)-1]

		if curr.Start <= last.End {
			if curr.End > last.End {
				last.End = curr.End
			}
		} else {
			merged = append(merged, curr)
		}
	}

	return merged
}
